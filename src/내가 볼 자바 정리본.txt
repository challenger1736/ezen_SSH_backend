

★★★★★★★★★★★★★★★ 선언과 대입을 헷갈리지 말자 ★★★★★★★★★★★★★★★★
★               가끔 이렇게 기본적인 것을 놓쳐서 헷갈릴 때가 있다               ★
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★


.이란 접근연산자이다.
Null + 기본 자료형은 .으로 메소드를 부를수 없음! 메소드가 없으니까.

등록 등록시마다 클래스의 new로 힙을 생성해줘야 하나의 new(하나의 인스턴스) , 하나의 new(하나의 인스턴스) 이런식으로 추가가 된다.
밖에 new가 한개 밖에없다면, 모두 다 같은 new 하나의 형식이 되므로 다같이 값들이 바뀌는 형태가 된다. - 싱글톤의 효과와 비슷한 느낌이라 생각하면 됨.

문자열은 불변이다. 자르고 재대입을 해줘야 그 문자열이 자른게 보인다.

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★ MVC 모델의 흐름 ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

View에서 받아서 Dto클래스의 하나의 값에 대입하고(컨트롤러의 생성자에), 그 해당 Dto하나를 컨트롤러에 넣어서 Dao 실행
그 Dao로 실행된 값으로 컨트롤러

순서
VdtoCdtoDao값C값V / VCDaoCV

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

근데 하나의 값에 하나를 넣으면 문제는 안생기나? 그것을 보자.

System.out.println(Arrays.toString(배열이름)); // 배열내 객체들의 주소확인.



생성자는 객체 생성을 하기에 생성자이다.
결국 new 클래스이름(); 은 생성자하나를 객체로 만드는 것이다.



toString메소드에 관해
//여러 프로그래밍 언어에서는 객체가 문자열로 변환될 때 자동으로 toString 메서드가 호출되기 때문에 toString을 생략해도 객체의 값들이 보인다.
//객체의 주소대신 나오게하는 toString 메소드를 넣어놓으면 주소대신 값이 나온다.

객체의 필드를 부를때 주로 필드는 private으로 한다.
그래서 게터세터로 부르는 형식이 많다. // 게터는 그 메소드의 리턴값을 받는 방식, 세터는 void로 그냥 값만 넣는 방식임이 머리속에 그려져야한다.


★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★


    - (접근제한자 public/default) (final) class 클래스명{}
    - (접근제한자 public/default/protected/private)(정적 static/ 인스턴스) (final) 타입 필드명;
    - (접근제한자 public/default/protected/private) 생성자(){}
//final 하면 생성자를 변경할 수 없다는 뜻이므로 생성자에 할 필요가 없다.
    - (접근제한자 public/default/protected/private)(정적 static/ 인스턴스) (final) 반환타입 메소드명(){}

      - 지역변수 : 함수안에서 // 지역변수는 절대 static이 될 수 없네
            (final) 타입 변수명; >> 어차피 외부에서 못쓰므로 접근제한자는 못 쓰게해놨음(지역변수, 스택이기 때문에)

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★


        접근제한자 : public/private/protected/(default)
        정적 : static
        최종 : final
        현재객체 : this
        상위객체 : super
        상속 : 자식 extends 부모 {} 자식클래스에서 부모를 고른다. 부모는 자식을 모른다.


★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

        ResultSet(rs)는 Query로 빼내서 get을 주로 쓸테고,(그것을 다시 자바에 있는 Dto에 set할 것이다.) // 불러올 때만 쓰이는 곳
        예> ps = conn.preparedStatement;
        rs = ps.executeQuery; // DB에서 빼오기
        rs.next()<< 이건 레코드 부르기 // 불린으로 나옴, true or false
        담을Dto명.set담을변수명(rs.getInt("필드명"))
        담을Dto명.set담을변수명(rs.getString("필드명"))



        preparedStatement(Ps)는 아직 넣기전이므로 sql의 ?에 setString, setint 등으로 주로 쓴다.
        String sql = insert into 테이블명(필드명, 필드명, 필드명) values (?, ?, ?);
        예> ps = conn.preparedStatement;

        ps.setInt(1, 받아온Dto의 게터)//1번째 물음표에 넣기
        ps.setInt(2, 받아온Dto의 게터)//2번째 물음표에 넣기
        ps.setInt(3, 받아온Dto의 게터)//3번째 물음표에 넣기

        그리고 그 ps를 이제 넣어버렸!
        ps.executeUpdate() // int로 나옴, 레코드 1개가 영향받으면 1이 나오겠지?

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

인터페이스는 자기 스스로 객체를 만들수 없다. 구현 클래스를 따로 두고 그 객체를 부르거나 익명 구현체를 (자기 스스로 오버라이딩) 만든다.